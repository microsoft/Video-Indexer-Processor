"""
Copyright (c) Microsoft Corporation.
Licensed under the MIT license.
"""
import bisect
import logging as log
from enrichment.insights_splitter.time_parser import TimeParser
from collections import OrderedDict
import copy

import os
log_text = os.getenv("LOG_PREFIX")


class VIinsightsToSegmentsSplitter():
    """
        The Video Indexer to segments splitter is intended to create shorter insights based on the
        video indexer "shots" and "scenes" calculations.
    """

    def __init__(self, configuration: dict):
        """
        Args:
            configuration (dict): Configuration of static fields to be copied
        """
        self.configuration = configuration
        self.interval_duration = 10
        self.overlap = 'interval'

    def split_vi_insights(self, vi_insights: dict, segment_type: str, **kwargs) -> OrderedDict:
        """
            Splits VI (Video Indexer) insights generated by VI into segments of varying lengths.
            Returns a list of shorter json files where each insight is binned into the relevant
            segment.
        Args:
            vi_insights (dict): raw VI  insights JSON file
            segment_type (str): "scenes": splits insights into varying lengths based on VI scenes.
                                "shots" : splits insights into varying lengths based on VI shots.
                                "interval": splits insights into equal length segments sized n
                                seconds (last segment may be shorter, dependent on video length)

            Additional keyword arguments may be passed:

            overlap (str, optional): "first": If an insight occurrence spans across multiple segments
                                              the insight is attributed to the first segment alone
                                     "duplicate: If an insight occurrence spans across multiple
                                                segment, the insight is duplicated across all
                                                relevant segments. Defaults to 'first'.
            keys_to_extract (str, optional): List of keys to be parsed to individual segments.
            interval_duration (int): Interval duration in seconds, only relevant to
                                    "segment_type" = "interval"
        Returns:
            OrderedDict: Segments including VI insights assigned based on timestamp.
            Each Dictionary key represents the segment start time in seconds.
        """
        # initialize configuration variables
        self.overlap = kwargs.pop('overlap', self.configuration["DEFAULT_OVERLAP"])
        keys_to_extract = kwargs.pop('keys_to_extract', self.configuration["INSIGHTS_TO_PARSE"])
        int_dur = self.configuration["DEFAULT_INTERVAL_DURATION"]
        self.interval_duration = kwargs.pop('interval_duration', int_dur)

        # initialize segments based on parameters
        segments = self._initialize_segments(vi_insights, segment_type)

        # assign information based on overlap strategy
        final_segments = self._assign_segment_information(segments, vi_insights, keys_to_extract)
        return final_segments

    def _assign_segment_information(self, segments: OrderedDict, vi_insights: dict, keys_to_extract: list):
        """
            Assigns information from vi_insights into the relevant segment based on the
            overlap strategy
        Args:
            segments (OrderedDict): initialized segments
        Returns:
            OrderedDict: Segments including VI insights assigned based on timestamp
        """

        for key in keys_to_extract:
            log.debug(f"splitting key {key} using overlap {self.overlap}")
            segments = self._split_key_insights(segments, vi_insights, key)
        return segments

    def _initialize_segments(self, vi_insights: dict, segment_type: str) -> OrderedDict:
        """
            Execute splitting strategy based on passed parameters

        Args:
            vi_insights (dict): raw VI  insights JSON file
            segment_type (str): "scenes": splits insights into varying lengths based on VI scenes.
                                "shots" : splits insights into varying lengths based on VI shots.
                                "interval": splits insights into equal length segments sized n
                                seconds (last segment may be shorter, dependent on video length)
        Returns:
            dict: A dictionary of segments, each key contains the segment start time in seconds
                  and the relevant content
        """

        if segment_type in ('scenes', 'shots'):
            segments = self._initialize_shot_scene_segments(vi_insights, look_at=segment_type)
        else:
            segments = self._initialize_interval_segments(vi_insights)
        return segments

    def _initialize_interval_segments(self, vi_insights: dict):
        """
        Args:
            vi_insights (dict): raw VI  insights JSON file

        Raises:
            Exception: An Exception when interval_duration <1 or not of integer type

        Returns:
            OrderedDict: Empty segments where the keys are initialized based on the
            passed parameters
        """
        # validate interval is of numeric type
        self._is_config_valid()
        video_duration = vi_insights.get('durationInSeconds', 0)

        # Check if interval length is longer than the entire video duration
        if self.interval_duration > video_duration:
            VIinsightsToSegmentsSplitter._return_single_segment(vi_insights, video_duration)

        # create numeric intervals with equal size
        ranges = list(range(0, video_duration + 1, self.interval_duration))

        # initialized segments
        segments = OrderedDict()

        # attach mutual information to each segment
        for rng in ranges:
            segments[rng] = self._attach_mutual_info_to_segments(vi_insights)

        return segments

    @staticmethod
    def _return_single_segment(vi_insights: dict, video_duration: int) -> OrderedDict:
        """
            Returns a single segment containing the full vi_insights content
        Args:
            vi_insights (dict): Raw VI insights

        Returns:
            OrderedDict: Single segment starting with time 0.0
        """

        log.info(f'{log_text} Video duration is {video_duration} seconds, the interval is too long. \
                        Returning the insights for the entire video')
        res = OrderedDict()
        res[0.0] = vi_insights
        return res

    def _attach_mutual_info_to_segments(self, vi_insights: dict):
        """
            Returns all the VI insights which are static and aren't dependent on timestamps.
        Args:
            vi_insights (dict): Original VI insights
        """

        # copy original dictionary so not to lose content
        mutual = copy.deepcopy(vi_insights)

        # Remove keys which will be reconstructed or redundant
        mutual.pop('videosRanges', None)

        # Keep mutual information from summarizedInsights key
        mutual.pop('summarizedInsights', None)
        keep_keys = self.configuration["SUMMARIZED_INSIGHTS_TO_KEEP"]
        summ = 'summarizedInsights'
        if summ not in vi_insights:
            mutual['summarizedInsights'] = dict()
        else:
            mutual_summarized = {key: vi_insights[summ].get(key, None) for key in keep_keys}
            mutual['summarizedInsights'] = copy.deepcopy(mutual_summarized)

        # Reset all keys to be reassigned as segments as empty lists, keeping all
        # static fields untouched
        videos = mutual['videos'][0]
        insights = videos.pop('insights', None)
        for key in self.configuration['INSIGHTS_TO_PARSE']:
            insights[key] = list()
        videos['insights'] = insights
        mutual['videos'][0] = videos
        return mutual

    def _initialize_shot_scene_segments(self, vi_insights: dict, look_at='scenes') -> OrderedDict:
        """
            The function generates an ordered dictionary containing all the insights split into
            'shots/scenes'.
        Args:
            vi_insights (dict): original vi_insights as generated by Video Indexer
            look_at (str, optional): Which granulation to extract.
                                    'shots' for extracting shot segments, 'scene' for scene
                                    segment extractions. Defaults to 'scenes'.

        Returns:
            OrderedDict: Returns an Ordered dictionary where each key represents the beginning
            of a new segment.
        """

        intervals = vi_insights['videos'][0]['insights'][look_at]
        interval_start_time = [x['instances'][0]['start'] for x in intervals]
        shot_str_to_seconds = [TimeParser.string_time_to_seconds(x) for x in interval_start_time]

        segments = OrderedDict()
        # attach mutual information to each segment
        mutual_insights = self._attach_mutual_info_to_segments(vi_insights)
        for rng in shot_str_to_seconds:
            copy_mutual = copy.deepcopy(mutual_insights)
            segments[rng] = copy_mutual
        return segments

    def _split_key_insights(self, segments: OrderedDict, vi_insights: dict, key: str):
        """
            This function implements assignment of information_pieces into segments using the
            selected overlap strategy.
        Args:
            segments (dict): Dictionary representing segments
            vi_insights (dict): Raw VI insights

        Returns:
            OrderedDict: Split a single "key" of VI insights into segments
        """

        insights_collection = vi_insights['videos'][0]['insights'].get(key, None)
        # Return segments unchanged if key is missing from vi_insights
        if insights_collection is None:
            return segments
        # Retrieve the start time of each segment
        segment_keys = list(segments.keys())

        for info_piece in insights_collection:
            for instance in info_piece['instances']:
                if self.overlap == 'duplicate':
                    segments = VIinsightsToSegmentsSplitter._split_key_insights_duplicate(segments, segment_keys, key, instance, info_piece)
                else:
                    segments = VIinsightsToSegmentsSplitter._split_key_insights_first(segments, segment_keys, key, instance, info_piece)
        return segments

    @staticmethod
    def _split_key_insights_first(segments: OrderedDict, segment_keys: list, key: str, instance: dict, info_piece: dict):
        """
            This function implements assignment of information_pieces into segments using the
            'first' overlap strategy.
            'first' overlap - If an information piece duration spans over multiple segments,
            it's assigned only to the first relevant segment.
        Args:
            segments (dict): Dictionary representing segments
            segment_keys (list): List of start times (in seconds) of each segment
            key (str): Name of the insight we're working on
            instance (dict): The timestamp relevant to the insight
            info_piece (dict): The insight information and data

        Returns:
            OrderedDict: Returns segments with "key" instances assigned to relevant bins
        """
        # Get start seconds of the information piece instance
        instance_start_time = TimeParser.string_time_to_seconds(instance['start'])

        # Identify the first relevant segment to place the information piece instance
        bin_index = bisect.bisect_right(segment_keys, instance_start_time) - 1

        # Initialized list of instances
        if key not in segments[segment_keys[bin_index]]['videos'][0]['insights']:
            segments[segment_keys[bin_index]]['videos'][0]['insights'][key] = list()

        # Add instances to list
        segments[segment_keys[bin_index]]['videos'][0]['insights'][key].append(info_piece)
        return segments

    @staticmethod
    def _split_key_insights_duplicate(segments: OrderedDict, segment_keys: list, key: str, instance: dict, info_piece: dict):
        """
            This function implements assignment of information_pieces into segments using the
            'duplicate' overlap strategy.
            'duplicate' overlap - If an information piece duration spans over multiple segments,
            the information is assign to every relevant segment
        Args:
            segments (dict): Dictionary representing segments
            segment_keys (list): List of start times (in seconds) of each segment
            key (str): Name of the insight we're working on
            instance (dict): The timestamp relevant to the insight
            info_piece (dict): The insight information and data

        Returns:
            OrderedDict: Returns segments with "key" instances assigned to relevant bins
        """

        # Get start seconds of the information piece instance
        instance_start_time = TimeParser.string_time_to_seconds(instance['start'])
        instance_end_time = TimeParser.string_time_to_seconds(instance['end'])

        # Identify the first relevant segment to place the information piece instance
        bin_index_start = bisect.bisect_right(segment_keys, instance_start_time) - 1
        bin_index_end = bisect.bisect_right(segment_keys, instance_end_time) - 1
        relevant_bins = range(bin_index_start, bin_index_end + 1)

        # Initialized list of instances
        for bin_index in relevant_bins:
            if key not in segments[segment_keys[bin_index]]['videos'][0]['insights']:
                segments[segment_keys[bin_index]]['videos'][0]['insights'][key] = list()

            # Add instances to list
            segments[segment_keys[bin_index]]['videos'][0]['insights'][key].append(info_piece)

        return segments

    def _is_config_valid(self,):

        # validate that interval duration is numeric type
        if not isinstance(self.interval_duration, int):
            log.error(f'{log_text} You chose to split insights using equal length interval but did\
                 not provide the length, please provide integer')
            raise Exception
        if self.interval_duration < 1:
            log.error(f'{log_text} Interval duration < 1, please provide an integer >=1')
            raise Exception
        if self.overlap not in ('interval', 'scenes', 'shots'):
            log.warning(f"{log_text} overlap method: {self.overlap} is not identified, valid methods are: interval, scenes, shots.\n\
            Executing default strategy 'interval' with 10 second interval duration")
        return True
